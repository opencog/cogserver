/*
 * tests/shell/JsonShellUTest.cxxtest
 *
 * Test for JSON Shell functionality
 * Copyright (c) 2024 OpenCog Contributors
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses/
 */

#include <thread>
#include <unistd.h>

#include <opencog/cogserver/server/CogServer.h>

using namespace opencog;

std::string json_cmd_exec(const char* cmd)
{
    char buf[1000];
    std::string result;
    std::shared_ptr<FILE> pope(popen(cmd, "r"), pclose);
    if (!pope) throw std::runtime_error("popen() failed!");
    while (!feof(pope.get())) {
        if (fgets(buf, sizeof(buf), pope.get()) != NULL)
            result += buf;
    }
    return result;
}

class JsonShellUTest : public CxxTest::TestSuite
{
private:
    CogServer* csrv;
    std::thread* main_loop;
    int port = 17335;  // Different port from McpShellUTest

public:
    JsonShellUTest()
    {
        logger().set_level(Logger::INFO);
    }

    ~JsonShellUTest()
    {
        if (!CxxTest::TestTracker::tracker().suiteFailed())
            std::remove(logger().get_filename().c_str());
    }

    void setUp()
    {
        csrv = new CogServer();
        csrv->loadModules();
        csrv->enableNetworkServer(port);
        main_loop = new std::thread(&CogServer::serverLoop, csrv);

        // Wait for the cogserver to finish initializing
        sleep(1);
    }

    void tearDown()
    {
        csrv->stop();
        main_loop->join();
        delete main_loop;
        delete csrv;
        csrv = nullptr;
    }

    void testJsonShellBasic()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // Test basic JSON shell interaction
        std::string cmd = "echo 'json\n.\n' | nc -q 1 localhost " + std::to_string(port);
        int rc = system(cmd.c_str());
        TS_ASSERT_EQUALS(rc, 0);

        logger().debug("END TEST: %s", __FUNCTION__);
    }

    void testJsonShellQuery()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // Test JSON query functionality with AtomSpace.version() using netcat
        std::string result = json_cmd_exec(
            "echo 'json\\nAtomSpace.version()\\n' | nc -q 1 localhost 17335");

        // The reply should contain a version number
        TS_ASSERT(result.size() > 0);
        TS_ASSERT(result.find(".") != std::string::npos);

        logger().debug("END TEST: %s", __FUNCTION__);
    }

    void testJsonShellEvaluator()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // Test JSON shell evaluation via netcat
        std::string result = json_cmd_exec(
            "echo 'json\\nAtomSpace.version()\\n' | nc -q 1 localhost 17335");

        TS_ASSERT(result.size() > 0);
        // The version should be a numeric string with a dot
        TS_ASSERT(result.find(".") != std::string::npos);

        logger().debug("END TEST: %s", __FUNCTION__);
    }

    void testJsonShellAtomSpaceIntegration()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // First, add an atom using the Scheme shell
        int rc = system("echo '(Concept \"test-concept-json\")' | nc -q 1 localhost 17335");
        TS_ASSERT_EQUALS(rc, 0);
        usleep(50000);

        // Test JSON shell can access the atom
        std::string result = json_cmd_exec(
            "echo 'json\\nAtomSpace.haveNode(\"Concept\", \"test-concept-json\")\\n' | nc -q 1 localhost 17335");

        // Should return "true"
        TS_ASSERT(result.find("true") != std::string::npos);

        logger().debug("END TEST: %s", __FUNCTION__);
    }

    void testJsonShellGetAtoms()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // Add some atoms using the Scheme shell
        int rc = system("echo '(Concept \"json-test-1\")' | nc -q 1 localhost 17335");
        TS_ASSERT_EQUALS(rc, 0);
        usleep(50000);
        rc = system("echo '(Concept \"json-test-2\")' | nc -q 1 localhost 17335");
        TS_ASSERT_EQUALS(rc, 0);
        usleep(50000);
        rc = system("echo '(Number 42)' | nc -q 1 localhost 17335");
        TS_ASSERT_EQUALS(rc, 0);
        usleep(50000);

        // Get all ConceptNodes via JSON shell
        std::string result = json_cmd_exec(
            "echo 'json\\nAtomSpace.getAtoms(\"ConceptNode\")\\n' | nc -q 1 localhost 17335");

        TS_ASSERT(result.find("json-test-1") != std::string::npos);
        TS_ASSERT(result.find("json-test-2") != std::string::npos);

        logger().debug("END TEST: %s", __FUNCTION__);
    }

    void testJsonShellMakeAtom()
    {
        logger().debug("BEGIN TEST: %s", __FUNCTION__);

        // Create a new atom via JSON command
        std::string result = json_cmd_exec(
            "echo 'json\\nAtomSpace.makeAtom({\"type\": \"Concept\", \"name\": \"json-created\"})\\n' | nc -q 1 localhost 17335");

        TS_ASSERT(result.find("true") != std::string::npos);

        // Verify the atom was created by checking with haveNode
        std::string verify = json_cmd_exec(
            "echo 'json\\nAtomSpace.haveNode(\"Concept\", \"json-created\")\\n' | nc -q 1 localhost 17335");

        TS_ASSERT(verify.find("true") != std::string::npos);

        logger().debug("END TEST: %s", __FUNCTION__);
    }
};