/*
 * tests/persist/dht/DeleteUTest.cxxtest
 *
 * Test deletion from backing store.  Assumes PersistUTest is passing.
 * Ported from tests/persist/sql/multi-driver/DeleteUTest.cxxtest
 *
 * Copyright (C) 2008, 2009, 2013, 2017, 2019 Linas Vepstas <linasvepstas@gmail.com>
 *
 * LICENSE:
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

#include <cstdio>

#include <opencog/atoms/atom_types/atom_types.h>
#include <opencog/atoms/base/Atom.h>
#include <opencog/atoms/base/Link.h>
#include <opencog/atoms/base/Node.h>
#include <opencog/atoms/truthvalue/SimpleTruthValue.h>
#include <opencog/persist/dht/DHTAtomStorage.h>
#include <opencog/persist/dht/DHTPersistSCM.h>

#include <opencog/util/Logger.h>

using namespace opencog;

class DeleteUTest :  public CxxTest::TestSuite
{
    private:
        AtomSpace *_as;
        DHTPersistSCM *_pm;
        std::string uri;
        std::string boot;
        DHTAtomStorage *astore;

        NodePtr n1[10];
        NodePtr n2[10];
        NodePtr n3[10];
        NodePtr n4[10];
        LinkPtr l[10];
        LinkPtr l2[10];
        LinkPtr l3[10];
        Handle h1[10];
        Handle h2[10];
        Handle h3[10];
        Handle h4[10];
        Handle hl[10];
        Handle hl2[10];
        Handle hl3[10];

    public:

        DeleteUTest(void);
        ~DeleteUTest()
        {
            delete astore;

            // erase the log file if no assertions failed
            if (!CxxTest::TestTracker::tracker().suiteFailed())
                std::remove(logger().get_filename().c_str());
        }

        void setUp(void);
        void tearDown(void);

        void add_to_space(int, AtomSpace *, std::string id);
        void fetch_space(int, AtomSpace *);
        void check_space(int, AtomSpace *, std::string dbgmsg);
        void check_remove(int, AtomSpace *, std::string dbgmsg);
        void check_empty(int, AtomSpace *);
        void extract_links(int, AtomSpace *);
        void delete_links(int, AtomSpace *);
        void extract_nodes(int, AtomSpace *);
        void delete_nodes(int, AtomSpace *);
        void atomCompare(AtomPtr, AtomPtr, std::string);
        void tvMiscompare(AtomPtr, AtomPtr, std::string);

        void test_remove(void);

        void test_recurse(void);
};

DeleteUTest:: DeleteUTest(void)
{
    logger().set_level(Logger::DEBUG);
    logger().set_print_to_stdout_flag(true);
    logger().set_sync_flag(true);

    uri = "dht:///atomspace-dht-test";
    boot = "dht://localhost:4555/";

    // Create a singe DHT node that will act as
    // as the repo for the duration of the test.
    astore = new DHTAtomStorage("dht://:4555/");
    if (!astore->connected())
    {
        logger().error("DeleteUTest: cannot setup a DHT node");
        exit(1);
    }
}

/*
 * This is called once before each test, for each test (!!)
 */
void DeleteUTest::setUp(void)
{
    _as = new AtomSpace();
}

void DeleteUTest::tearDown(void)
{
    delete _as;
}

// ============================================================

void DeleteUTest::atomCompare(AtomPtr a, AtomPtr b, std::string where)
{
    printf("Check %s expect %s\n", where.c_str(), a->to_string().c_str());
    TSM_ASSERT("No atom found", b != nullptr);

    if (nullptr == b) return;

    TSM_ASSERT_EQUALS("Type mismatch", a->get_type(), b->get_type());

    NodePtr na(NodeCast(a));
    NodePtr nb(NodeCast(b));
    if (na and nb)
    {
        TSM_ASSERT_EQUALS("Name mismatch", na->get_name(), nb->get_name());
    }

    LinkPtr la(LinkCast(a));
    LinkPtr lb(LinkCast(b));
    if (la and lb)
    {
        TSM_ASSERT_EQUALS("Arity mismatch", la->get_arity(), lb->get_arity());
        if (*la != *lb)
        {
            printf("Mismatching la = %s\n", la->to_string().c_str());
            printf("Mismatching lb = %s\n", lb->to_string().c_str());
            TSM_ASSERT_EQUALS("Link mis-match", la, lb);
        }
    }

    TruthValuePtr ta = a->getTruthValue();
    TruthValuePtr tb = b->getTruthValue();
    if (ta or tb)
    {
        TSM_ASSERT("Missing truth value", ta);
        TSM_ASSERT("Missing truth value", tb);
        if (ta and tb)
        {
            if (not ((*ta) == (*tb)))
            {
                printf("Error, truth value miscompare on %s\n"
                    "\tma=%f mb=%f ca=%f cb=%f\n",
                    where.c_str(),
                    ta->get_mean(), tb->get_mean(),
                    ta->get_confidence(), tb->get_confidence());
            }
            TSM_ASSERT("Truth value miscompare", (*ta)==(*tb));
        }
    }
}

// Passes only if the TV's are different!
void DeleteUTest::tvMiscompare(AtomPtr a, AtomPtr b, std::string where)
{
    if (nullptr == a or nullptr == b) return;

    TruthValuePtr ta = a->getTruthValue();
    TruthValuePtr tb = b->getTruthValue();
    if (ta and tb)
    {
        TSM_ASSERT("Truth value should not match! " + where, (*ta)!=(*tb));
    }
    if (nullptr==ta and nullptr==tb)
    {
        TSM_ASSERT("Truth value null!! " + where, false);
    }
}

// ============================================================

void DeleteUTest::add_to_space(int idx, AtomSpace *as, std::string id)
{
    // Create an atom ...
    TruthValuePtr stv(SimpleTruthValue::createTV(0.11, 100+idx));
    h1[idx] = as->add_node(SCHEMA_NODE, id + "fromNode");
    h1[idx]->setTruthValue(stv);
    n1[idx] = NodeCast(h1[idx]);

    TruthValuePtr stv2(SimpleTruthValue::createTV(0.22, 200+idx));
    h2[idx] = as->add_node(SCHEMA_NODE, id + "toNode");
    h2[idx]->setTruthValue(stv2);
    n2[idx] = NodeCast(h2[idx]);

    TruthValuePtr stv3(SimpleTruthValue::createTV(0.33, 300+idx));
    h3[idx] = as->add_node(SCHEMA_NODE, id + "third wheel");
    h3[idx]->setTruthValue(stv3);
    n3[idx] = NodeCast(h3[idx]);

    // The NumberNode will go through the AtomTable clone factory
    // and should thus elicit any errors in clone uuid handling.
    char buf[40]; sprintf(buf, "%f", idx+0.14159265358979);
    h4[idx] = as->add_node(NUMBER_NODE, buf);
    TruthValuePtr stv4(SimpleTruthValue::createTV(0.44, 400+idx));
    h4[idx]->setTruthValue(stv4);
    n4[idx] = NodeCast(h4[idx]);

    HandleSeq hvec;
    hvec.push_back(h1[idx]);
    hvec.push_back(h2[idx]);
    hvec.push_back(h3[idx]);
    hvec.push_back(h4[idx]);

    // Note that SetLink is an unordered link.
    TruthValuePtr stv5(SimpleTruthValue::createTV(0.55, 500+idx));
    hl[idx] = as->add_link(SET_LINK, std::move(hvec));
    hl[idx]->setTruthValue(stv5);
    l[idx] = LinkCast(hl[idx]);

    TruthValuePtr stv6(SimpleTruthValue::createTV(0.66, 600+idx));
    hl2[idx] = as->add_link(LIST_LINK, hl[idx], h2[idx]);
    hl2[idx]->setTruthValue(stv6);
    l2[idx] = LinkCast(hl2[idx]);

    TruthValuePtr stv7(SimpleTruthValue::createTV(0.77, 700+idx));
    hl3[idx] = as->add_link(EVALUATION_LINK, h1[idx], hl2[idx], h3[idx]);
    hl3[idx]->setTruthValue(stv7);
    l3[idx] = LinkCast(hl3[idx]);
}

void DeleteUTest::fetch_space(int idx, AtomSpace *space)
{
    AtomPtr ab1 = createNode(n1[idx]->get_type(), n1[idx]->get_name());
    Handle hb1(ab1->get_handle());
    space->fetch_atom(hb1);

    AtomPtr ab2 = createNode(n2[idx]->get_type(), n2[idx]->get_name());
    Handle hb2(ab2->get_handle());
    space->fetch_atom(hb2);

    AtomPtr ab3 = createNode(n3[idx]->get_type(), n3[idx]->get_name());
    Handle hb3(ab3->get_handle());
    space->fetch_atom(hb3);

    AtomPtr ab4 = createNode(n4[idx]->get_type(), n4[idx]->get_name());
    Handle hb4(ab4->get_handle());
    space->fetch_atom(hb4);

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    std::string ref = _pm->do_atom_hash(hl[idx]);
    std::string valus = _pm->do_examine(ref);
    printf("Pre fetch memuid=%s\n", ref.c_str());
    printf("Pre fetch have vals=%s\n", valus.c_str());

    AtomPtr alb = createLink(hvec, hl[idx]->get_type());
    Handle hlb(alb->get_handle());

    Handle flb = space->fetch_atom(hlb);
    ref = _pm->do_atom_hash(hl[idx]);
    valus = _pm->do_examine(ref);
    printf("Post fetch have vals=%s\n", valus.c_str());


    HandleSeq hv2({hlb, hb2});
    AtomPtr alb2 = createLink(hv2, hl2[idx]->get_type());
    Handle hlb2(alb2->get_handle());
    space->fetch_atom(hlb2);

    HandleSeq hv3({hb1, hlb2, hb3});
    AtomPtr alb3 = createLink(hv3, hl3[idx]->get_type());
    Handle hlb3(alb3->get_handle());
    space->fetch_atom(hlb3);
}

void DeleteUTest::check_space(int idx, AtomSpace *space, std::string dbgmsg)
{
    dbgmsg += "-idx=" + std::to_string(idx);
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    atomCompare(h1[idx], hb1, dbgmsg + "-hb1");

    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    atomCompare(h2[idx], hb2, dbgmsg + "-hb2");

    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    atomCompare(h3[idx], hb3, dbgmsg + "-hb3");

    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());
    atomCompare(h4[idx], hb4, dbgmsg + "-hb4");

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    atomCompare(hl[idx], hlb, dbgmsg + "-hlinkb");

    HandleSeq hv2({hlb, hb2});
    Handle hlb2 = space->get_handle(hl2[idx]->get_type(), hv2);
    atomCompare(hl2[idx], hlb2, dbgmsg + "-hlinkb2");

    HandleSeq hv3({hb1, hlb2, hb3});
    Handle hlb3 = space->get_handle(hl3[idx]->get_type(), hv3);
    atomCompare(hl3[idx], hlb3, dbgmsg + "-hlinkb3");
}

void DeleteUTest::check_remove(int idx, AtomSpace *space, std::string dbgmsg)
{
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    tvMiscompare(hl[idx], hlb, dbgmsg + "-hlinkb");

    HandleSeq hv2({hlb, hb2});
    Handle hlb2 = space->get_handle(hl2[idx]->get_type(), hv2);
    tvMiscompare(hl2[idx], hlb2, dbgmsg + "-hlinkb2");

    HandleSeq hv3({hb1, hlb2, hb3});
    Handle hlb3 = space->get_handle(hl3[idx]->get_type(), hv3);
    tvMiscompare(hl3[idx], hlb3, dbgmsg + "-hlinkb3");
}

void DeleteUTest::check_empty(int idx, AtomSpace *space)
{
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb1 == Handle::UNDEFINED);

    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb2 == Handle::UNDEFINED);

    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb3 == Handle::UNDEFINED);

    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb4 == Handle::UNDEFINED);

    HandleSeq hvec;
    hvec.push_back(h1[idx]);
    hvec.push_back(h2[idx]);
    hvec.push_back(h3[idx]);
    hvec.push_back(h4[idx]);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    TSM_ASSERT("Should not find this atom", hlb == Handle::UNDEFINED);
}

// This removes from atomspace, but not from the DB.
void DeleteUTest::extract_links(int idx, AtomSpace *as)
{
	as->extract_atom(hl3[idx]);
	as->extract_atom(hl2[idx]);
	as->extract_atom(hl[idx]);
}

// This should delete all the links from the database (and also
// the AtomSpace)
void DeleteUTest::delete_links(int idx, AtomSpace *as)
{
	as->remove_atom(hl3[idx]);
	as->remove_atom(hl2[idx]);
	as->remove_atom(hl[idx]);

	std::string ref = _pm->do_atom_hash(hl[idx]);
	std::string valus = _pm->do_examine(ref);
	printf("After delete memuid=%s\n", ref.c_str());
	printf("After delete have vals=%s\n", valus.c_str());
}

// This removes all the links, and one node, from atomspace,
// but not from the DB.
void DeleteUTest::extract_nodes(int idx, AtomSpace *as)
{
	as->extract_atom(h1[idx], true);
}

// This should delete all the links and one node from the database.
void DeleteUTest::delete_nodes(int idx, AtomSpace *as)
{
	as->remove_atom(h3[idx], true);
}

// ============================================================

void DeleteUTest::test_remove(void)
{
    logger().debug("BEGIN TEST: %s", __FUNCTION__);

    _pm = new DHTPersistSCM(_as);
    TSM_ASSERT("Persist Module not loaded", _pm);

    _pm->do_open(uri);
    _pm->do_bootstrap(boot);

    int idx = 0;
    add_to_space(idx++, _as, "AA-aa-wow ");
    add_to_space(idx++, _as, "BB-bb-wow ");
    add_to_space(idx++, _as, "CC-cc-wow ");
    add_to_space(idx++, _as, "DD-dd-wow ");
    add_to_space(idx++, _as, "EE-ee-wow ");

    /* Make sure UTF-8 works fine. */
    add_to_space(idx++, _as, "Попытка выбраться вызвала слабый стон ");
    add_to_space(idx++, _as, "はにがうりだそうであってるのかはち ");
    add_to_space(idx++, _as, "係拉丁字母");

    /* Verify that the atoms were added */
    int i;
    for (i=0; i<idx; i++)
        check_space(i, _as, "verify-add");

    /* Push all atoms out to the SQL DB */
    _as->store_atomspace();

    printf("Initial Atomspace size=%lu expect=%d\n", _as->get_size(), 7*idx);
    TSM_ASSERT("Initial unexpected atomspace size",
          ((unsigned)(7*idx)) == _as->get_size());
    /* Delete some atoms with non-empty incoming sets.
     * This should result in thier being removed from the atomspace,
     * but NOT fom the backend!
     */
    _as->barrier();

    for (i=0; i<idx; i++)
        extract_links(i, _as);

    printf("Atomspace size=%lu expect=%d\n", _as->get_size(), 4*idx);
    TSM_ASSERT("Post-extract unexpected atomspace size", ((unsigned)(4*idx)) == _as->get_size());

    /* Verify that the atoms can still be fetched from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, _as);
        check_space(i, _as, "verify-fetch");
    }

    /* This time, kill them in the backend too.  */
    for (i=0; i<idx; i++)
        delete_links(i, _as);

    printf("Post-remove size=%lu expect=%d\n", _as->get_size(), 4*idx);
    TSM_ASSERT("Post-remove unexpected atomspace size", ((unsigned)(4*idx)) == _as->get_size());

    /* Verify that the atoms are really gone from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, _as);
        check_remove(i, _as, "verify-gone");
    }

    printf("Post-referesh size=%lu expect=%d\n", _as->get_size(), 7*idx);
    TSM_ASSERT("Post-refetch unexpected atomspace size", ((unsigned)(7*idx)) == _as->get_size());

    /* Kill data for good */
    _as->clear();
    TSM_ASSERT("Non-empty atomspace", 0 == _as->get_size());

    /* Verify that the atoms are no longer being found. */
    for (i=0; i<idx; i++)
        check_empty(i, _as);

    /* Orderly shutdown avoids warning in Postgres log file. */
    _pm->do_close();

    delete _pm;
    _pm = nullptr;
    logger().debug("END TEST: %s", __FUNCTION__);
}

// ============================================================

void DeleteUTest::test_recurse(void)
{
    logger().debug("BEGIN TEST: %s", __FUNCTION__);

    _pm = new DHTPersistSCM(_as);
    TSM_ASSERT("Persist Module not loaded", _pm);

    _pm->do_open(uri);
    _pm->do_bootstrap(boot);

    int idx = 0;
    add_to_space(idx++, _as, "AA-aa-wow ");
    add_to_space(idx++, _as, "BB-bb-wow ");
    add_to_space(idx++, _as, "CC-cc-wow ");
    add_to_space(idx++, _as, "DD-dd-wow ");
    add_to_space(idx++, _as, "EE-ee-wow ");

    /* Make sure UTF-8 works fine. */
    add_to_space(idx++, _as, "Попытка выбраться вызвала слабый стон ");
    add_to_space(idx++, _as, "はにがうりだそうであってるのかはち ");
    add_to_space(idx++, _as, "係拉丁字母");

    /* Verify that the atoms were added */
    int i;
    for (i=0; i<idx; i++)
        check_space(i, _as, "verify-add");

    /* Push all atoms out to the SQL DB */
    _as->store_atomspace();

    /* Perform recursive extract of some nodes.
     * This should result in thier being removed from the atomspace,
     * but NOT fom the backend!
     */
    _as->barrier();

    int zap = 4;
    for (i=0; i<zap; i++)
        extract_nodes(i, _as);

    size_t expsz = 7*(idx-zap) + 3*zap;
    printf("Atomspace size=%lu expect=%lu\n",
         _as->get_size(), expsz);
    TSM_ASSERT("Unexpected atomspace size", expsz == _as->get_size());

    /* Verify that the atoms can still be fetched from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, _as);
        check_space(i, _as, "verify-fetch");
    }

    /* This time, kill them in the backend too.  */
    for (i=0; i<zap; i++)
        delete_nodes(i, _as);

    printf("Post-remove size=%lu expect=%lu\n",
         _as->get_size(), expsz);
    TSM_ASSERT("Unexpected atomspace size", expsz == _as->get_size());

    _as->barrier();

    /* Verify that the atoms are really gone from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, _as);
    }

    printf("Post-refetch size=%lu expect=%d\n",
         _as->get_size(), 7*idx);
    TSM_ASSERT("Unexpected atomspace size",
         ((unsigned) 7*idx) == _as->get_size());

    /* Check that the removed atoms really got zapped. */
    for (i=0; i<zap; i++) {
        check_remove(i, _as, "verify-zapped");
    }

    /* However, others should still be there. */
    for (i=zap; i<idx; i++) {
        check_space(i, _as, "verify-zap");
    }

    /* Kill data for good */
    _as->clear();
    TSM_ASSERT("Non-empty atomspace", 0 == _as->get_size());

    /* Verify that the atoms are no longer being found. */
    for (i=0; i<idx; i++)
        check_empty(i, _as);

    /* Orderly shutdown avoids warning in Postgres log file. */
    _pm->do_close();

    delete _pm;
    _pm  = nullptr;
    logger().debug("END TEST: %s", __FUNCTION__);
}

/* ============================= END OF FILE ================= */
